# 红黑树[O(logn)]
- 定义:
    - 根节点是黑色的；
    - 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
    - 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
    - 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点
   
- 特点
    - 是从二叉查找树基础上演变而来，是一颗保持相对平衡的二叉树，目的是为了防止树结构退化成链表，从而提高查找效率。
   
- 实现
   - 变色和旋转（左旋转和右旋转）
   
- 替代实现
    - 跳表
        - 原因:实现较容易
     
# 跳表
   - 根据数据，抽取部分数据做索引层，抽取的数据可用随机函数取模
# 冒泡，插入，选择[O(n^2)]
- 冒泡排序
    - 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作
    
- 插入排序
    - 存在`已排序区`和`未排序区`，插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束
    
- 选择排序
    - 选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾

# 快排，归并,堆排序[O(nlogn)]
- 归并排序
    - 先降待排序的数组进行分解，例如8个待排序数字，分别分为([4,4]),([2,2],[2,2]),([1],[1],[1],[1],[1],[1],[1],[1]),再合并排序，归并排序使用的就是`分治思想`。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。`归并排序用的是分治思想`，可以用递归来实现。

- 快速排序
    - 获取数组最后一个元素作为基点，分为小于基点和大于基点两个数组，两个数组也分别递归上面的步骤直到所有排序完成。
    
- 堆排序
    - 堆排序的过程大致分解成两个大的步骤，建堆和排序。
# 桶，计数，基数[O(n)]
- 桶排序
    - 核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。
    
- 计数排序
    - 划分相同值的桶(例如0-100分，划分101个桶)，将数值放入桶内，桶不再排序，就是一个有序的排序。
    
- 基数排序
    - 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了
    